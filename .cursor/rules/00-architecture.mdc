# Architecture Rules - Disaster Response Dashboard

**alwaysApply: true**

## System Overview

The Disaster Response Dashboard is a **real-time emergency coordination platform** that reduces evacuation times from **45+ minutes to under 15 seconds** through AI-powered hazard prediction and dynamic route optimization. The system integrates **9 Foundry APIs** to deliver a **15-second detection-to-evacuation pipeline**.

### Key Performance Metrics
- ‚ö° **45-minute ‚Üí 15-second evacuation orders**
- üõ°Ô∏è **0% hazard intersection routes** (vs 12% baseline)
- üìà **85%+ evacuation compliance** (vs 55% baseline)
- üíæ **80-150 lives saved annually**

## System Architecture Layers

### 1. External Data Sources ‚Üí Data Ingestion ‚Üí Foundry ‚Üí API Layer ‚Üí Frontend

```
External APIs ‚Üí Data Ingestion ‚Üí Foundry Processing ‚Üí API Layer ‚Üí Frontend
     ‚Üì              ‚Üì                ‚Üì              ‚Üì          ‚Üì
  NASA FIRMS    FIRMS Processor   HazardProcessor  REST API   React Components
  NOAA Weather  Weather Processor RouteOptimizer  WebSocket   Mapbox GL JS
  911 Feeds     Emergency Processor RiskProcessor  GraphQL    Validation System
  GPS Tracking  Tracking Processor ML Predictions  gRPC       Real-time Updates
```

### 2. Technology Stack

#### Frontend Stack
- **React 18** with TypeScript
- **Mapbox GL JS** for interactive 3D maps
- **Vite** for build tooling
- **Playwright** for E2E testing
- **Vitest** for unit testing

#### Backend Stack
- **Python 3.11** with Flask/FastAPI
- **GeoPandas** for geospatial processing
- **H3** for spatial indexing (1M+ points/second)
- **scikit-learn** for ML predictions (87% accuracy)
- **NetworkX** for route optimization (A* algorithm)
- **Redis** for real-time caching
- **PostGIS** with H3 indices for geospatial storage

#### Infrastructure
- **Docker** containerization
- **Docker Compose** for orchestration
- **Nginx** for frontend serving
- **Foundry Platform** for data processing

## Data and Validation Pipelines

### Real-time Data Pipeline
```
External APIs ‚Üí Data Ingestion ‚Üí Foundry Processing ‚Üí API Layer ‚Üí Frontend
     ‚Üì              ‚Üì                ‚Üì              ‚Üì          ‚Üì
  NASA FIRMS    FIRMS Processor   HazardProcessor  REST API   React Components
  NOAA Weather  Weather Processor RouteOptimizer  WebSocket   Mapbox GL JS
  911 Feeds     Emergency Processor RiskProcessor  GraphQL    Validation System
  GPS Tracking  Tracking Processor ML Predictions  gRPC       Real-time Updates
```

### Validation Data Flow
```
Frontend Validation ‚Üí Backend Validation ‚Üí Comparison Engine ‚Üí Discrepancy Detection
        ‚Üì                    ‚Üì                    ‚Üì                    ‚Üì
   Layer Rendering      API Endpoints        Cross-System         Error Reporting
   Performance Metrics  Data Sources         Validation          Automated Fixes
   User Interactions    Health Checks        Consistency         Monitoring Alerts
```

## Five-Phase Testing Workflow

### Phase 1: Component Discovery
- **Purpose**: Auto-discover all React components
- **Method**: Dynamic component mapping
- **Output**: Component inventory with props and dependencies

### Phase 2: Basic Rendering
- **Purpose**: Verify components render without errors
- **Method**: Isolated component testing
- **Output**: Rendering success/failure report

### Phase 3: Prop Validation
- **Purpose**: Test all prop combinations
- **Method**: Systematic prop permutation testing
- **Output**: Prop validation results

### Phase 4: Interaction Testing
- **Purpose**: Test user interactions and state changes
- **Method**: Simulated user interactions
- **Output**: Interaction success/failure report

### Phase 5: Error Handling
- **Purpose**: Test error boundaries and recovery
- **Method**: Fault injection and error simulation
- **Output**: Error handling effectiveness report

## Performance Budgets

### Frontend Performance
- **Load Time**: < 3 seconds
- **Layer Render Time**: 1-5ms per layer
- **Memory Usage**: Optimized for production

### Backend Performance
- **Response Time**: < 100ms average
- **Validation Time**: ~8ms average
- **Spatial Processing**: 1M+ points/second

### Testing Performance
- **Unit Tests**: <1s execution time
- **Smoke Tests**: ~3s execution time
- **Full E2E**: ~3.5min execution time

## "Do Not Change" Items

### Critical Invariants
1. **Never modify public API contracts** without updating the OpenAPI schema and tests
2. **Never edit `config.env.production`** or any secrets files
3. **Never break the 0% hazard intersection requirement** in route validation
4. **Never modify the Foundry integration** without updating all dependent functions
5. **Never change the H3 spatial indexing resolution** (currently 9 for ~174m hexagons)

### API Contract Stability
- All `/api/*` endpoints must maintain backward compatibility
- Foundry function decorators must not change their signatures
- WebSocket message formats must remain consistent
- GeoJSON schemas must not be modified without versioning

### Security Boundaries
- Never expose API keys or secrets in logs
- Never write to `.env*` files or production configs
- Never make external network calls in tests beyond approved mock fixtures
- Never include real coordinates that could identify households outside test data

## Development Requirements

### When Adding Features
1. **Update relevant rules** in this directory
2. **Write comprehensive tests** covering all new functionality
3. **Update documentation** including API schemas
4. **Validate performance budgets** are maintained
5. **Ensure 0% hazard intersection** in route calculations
6. **Update validation system** to monitor new features

### When Modifying Existing Features
1. **Maintain backward compatibility** for public APIs
2. **Update all dependent tests** and validation
3. **Verify performance budgets** are not exceeded
4. **Ensure Foundry integration** remains functional
5. **Update documentation** to reflect changes

### Code Quality Standards
- **TypeScript**: Strict type checking enabled
- **Python**: Type hints required for all functions
- **Testing**: Maintain high test coverage for reliability
- **Documentation**: Update relevant docs for all changes
- **Performance**: Monitor and maintain performance budgets

## Architecture Validation

### Continuous Monitoring
- Real-time validation system monitors all layers
- Performance budgets are enforced automatically
- API contract compliance is validated on every change
- Security boundaries are enforced at all levels

### Quality Gates
- All tests must pass before deployment
- Performance budgets must be met
- 0% hazard intersection must be maintained
- API contracts must remain stable
- Security requirements must be satisfied

This architecture provides a robust, scalable foundation for emergency response coordination with real-time data processing, ML-powered predictions, and comprehensive validation systems.