# Frontend Development Standards

## Component Architecture

### React Component Standards
- **Use functional React components** with hooks
- **Strict TypeScript types** for all props and state
- **No class components** - use functional components only
- **Custom hooks** for complex state logic and side effects

### Component Structure
```typescript
interface ComponentProps {
  // Define all props with strict types
  requiredProp: string;
  optionalProp?: number;
  callbackProp: (data: SomeType) => void;
}

const Component: React.FC<ComponentProps> = ({
  requiredProp,
  optionalProp,
  callbackProp
}) => {
  // Component implementation
  return <div>{/* JSX */}</div>;
};

export default Component;
```

## Data Fetching

### React Query Integration
- **Use React Query** for all data fetching operations
- **Implement proper caching** strategies for different data types
- **Handle loading and error states** consistently
- **Use optimistic updates** where appropriate

### Data Fetching Pattern
```typescript
import { useQuery, useMutation } from '@tanstack/react-query';

const useHazardData = () => {
  return useQuery({
    queryKey: ['hazards'],
    queryFn: () => fetchHazards(),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
  });
};
```

## Layer Management

### LayerManager Integration
When adding or updating layers, you **MUST**:

1. **Modify the `LayerManager`** to include the new layer
2. **Ensure `ValidationSystem` hooks are wired** for the new layer
3. **Add proper TypeScript types** for layer configuration
4. **Implement layer-specific validation** logic

### Layer Implementation Pattern
```typescript
interface LayerConfig {
  id: string;
  name: string;
  type: 'terrain' | 'buildings' | 'hazards' | 'units' | 'routes';
  enabled: boolean;
  opacity: number;
  data: GeoJSON.FeatureCollection;
}

const useLayerValidation = (layerId: string) => {
  const { validateLayer } = useValidationSystem();
  
  useEffect(() => {
    validateLayer(layerId);
  }, [layerId, validateLayer]);
};
```

### Required Layer Types
- **TerrainLayer**: 3D terrain visualization
- **BuildingsLayer**: Building extrusion and visualization
- **HazardsLayer**: Hazard zone visualization
- **EmergencyUnitsLayer**: Emergency unit tracking
- **EvacuationRoutesLayer**: Safe evacuation paths

## Testing Standards

### Unit Testing with Vitest
- **Write unit tests** in files ending `*.test.tsx`
- **Test component rendering** and user interactions
- **Mock external dependencies** (API calls, Mapbox, etc.)
- **Test error boundaries** and edge cases

### Unit Test Pattern
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import Component from './Component';

describe('Component', () => {
  it('renders correctly', () => {
    render(<Component requiredProp="test" />);
    expect(screen.getByText('test')).toBeInTheDocument();
  });

  it('handles user interactions', () => {
    const mockCallback = vi.fn();
    render(<Component requiredProp="test" callbackProp={mockCallback} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(mockCallback).toHaveBeenCalledWith(expectedData);
  });
});
```

### End-to-End Testing with Playwright
- **Write E2E tests** in `e2e/` directory
- **Test complete user workflows** and map interactions
- **Validate layer rendering** and performance
- **Test responsive behavior** across devices

### E2E Test Pattern
```typescript
import { test, expect } from '@playwright/test';

test('map loads and displays layers correctly', async ({ page }) => {
  await page.goto('/');
  
  // Wait for map to load
  await expect(page.locator('.mapboxgl-map')).toBeVisible();
  
  // Test layer toggles
  await page.click('[data-testid="hazards-toggle"]');
  await expect(page.locator('.hazards-layer')).toBeVisible();
  
  // Test map interactions
  await page.click('.mapboxgl-canvas');
  await expect(page.locator('.map-popup')).toBeVisible();
});
```

## Accessibility Standards

### Keyboard Navigation
- **All interactive elements** must be keyboard accessible
- **Tab order** must be logical and intuitive
- **Focus indicators** must be visible and clear
- **Skip links** for main content areas

### ARIA Attributes
- **Use semantic HTML** elements where possible
- **Add ARIA labels** for complex UI components
- **Implement ARIA live regions** for dynamic content
- **Ensure proper heading hierarchy** (h1, h2, h3, etc.)

### Accessibility Testing
```typescript
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

test('component has no accessibility violations', async () => {
  const { container } = render(<Component />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

## Performance Standards

### Code Splitting
- **Implement code splitting** for heavy layers and components
- **Use dynamic imports** for large dependencies
- **Lazy load** non-critical components
- **Optimize bundle size** with tree shaking

### Performance Optimization
```typescript
// Lazy load heavy components
const HeavyLayer = lazy(() => import('./HeavyLayer'));

// Use React.memo for expensive components
const ExpensiveComponent = React.memo(({ data }) => {
  // Component implementation
});

// Implement virtualization for large lists
import { FixedSizeList as List } from 'react-window';
```

### Performance Monitoring
- **Monitor render times** for all layers
- **Track memory usage** during map interactions
- **Validate performance budgets** (1-5ms per layer)
- **Use React DevTools Profiler** for optimization

## Map Integration

### Mapbox GL JS Standards
- **Use Mapbox GL JS** for all map functionality
- **Implement proper map lifecycle** management
- **Handle map events** consistently
- **Optimize layer rendering** performance

### Map Component Pattern
```typescript
import mapboxgl from 'mapbox-gl';

const MapComponent: React.FC = () => {
  const mapRef = useRef<mapboxgl.Map | null>(null);
  
  useEffect(() => {
    const map = new mapboxgl.Map({
      container: mapRef.current!,
      style: 'mapbox://styles/mapbox/streets-v11',
      center: [-122.4194, 37.7749],
      zoom: 10
    });
    
    mapRef.current = map;
    
    return () => map.remove();
  }, []);
  
  return <div ref={mapRef} className="map-container" />;
};
```

## State Management

### State Management Patterns
- **Use React Query** for server state
- **Use useState/useReducer** for local component state
- **Use Context API** for shared application state
- **Avoid prop drilling** with proper state lifting

### Context Pattern
```typescript
interface AppState {
  selectedLayer: string;
  mapViewport: Viewport;
  userPreferences: UserPreferences;
}

const AppContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
} | null>(null);

export const useAppState = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppState must be used within AppProvider');
  }
  return context;
};
```

## Error Handling

### Error Boundaries
- **Implement error boundaries** for component error handling
- **Provide fallback UI** for error states
- **Log errors** to monitoring systems
- **Graceful degradation** for non-critical features

### Error Boundary Pattern
```typescript
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }

    return this.props.children;
  }
}
```

## Development Workflow

### Code Quality
- **Use ESLint** for code quality enforcement
- **Use Prettier** for consistent code formatting
- **Use TypeScript strict mode** for type safety
- **Run tests** before committing changes

### Development Commands
```bash
# Development
npm run dev              # Start development server
npm run build            # Build for production
npm run preview          # Preview production build

# Testing
npm run test             # Run unit tests
npm run test:ui          # Run tests with UI
npm run test:coverage    # Run tests with coverage
npm run e2e              # Run E2E tests

# Code Quality
npm run lint             # Run ESLint
npm run lint:fix         # Fix ESLint issues
npm run format           # Format with Prettier
npm run type-check       # TypeScript type checking
```

## Integration Requirements

### Validation System Integration
- **Wire all new layers** with the ValidationSystem
- **Implement layer-specific validation** logic
- **Handle validation errors** gracefully
- **Provide user feedback** for validation issues

### API Integration
- **Use React Query** for all API calls
- **Handle loading and error states** consistently
- **Implement proper caching** strategies
- **Validate API responses** with TypeScript types

This frontend development standard ensures consistent, maintainable, and performant React components that integrate seamlessly with the disaster response dashboard's validation and monitoring systems.