# Security Standards

**alwaysApply: true**

## Critical Security Boundaries

### Environment and Configuration Files
- **NEVER write to `.env*` files** or any environment configuration files
- **NEVER edit `config.env.production`** or any production configuration
- **NEVER expose secrets or sensitive data** in logs, comments, or code
- **NEVER commit API keys, passwords, or tokens** to version control

### Secret Management
```bash
# FORBIDDEN - Never do this
echo "API_KEY=secret123" >> .env
echo "DATABASE_PASSWORD=password" >> config.env.production

# CORRECT - Use environment variables or secure config
export API_KEY="secret123"
# Or use proper secret management systems
```

### Logging and Data Exposure
- **NEVER log sensitive data** including API keys, passwords, or personal information
- **NEVER expose coordinates** that could identify real households outside test data
- **NEVER include real addresses** or personal information in test data
- **ALWAYS redact sensitive information** in error messages and logs

### Secure Logging Pattern
```python
import logging
import re

# FORBIDDEN - Never log sensitive data
logger.error(f"API call failed with key: {api_key}")
logger.info(f"User location: {user_lat}, {user_lon}")

# CORRECT - Redact sensitive information
logger.error("API call failed with key: [REDACTED]")
logger.info(f"User location: {redact_coordinates(user_lat, user_lon)}")

def redact_coordinates(lat: float, lon: float) -> str:
    """Redact coordinates to prevent identification of real households"""
    # Round to 2 decimal places to remove precision
    return f"{round(lat, 2)}, {round(lon, 2)}"

def redact_api_key(api_key: str) -> str:
    """Redact API key in logs"""
    if len(api_key) > 8:
        return f"{api_key[:4]}...{api_key[-4:]}"
    return "[REDACTED]"
```

## Network Security

### External Network Calls
- **AVOID external network calls** in tests beyond approved mock fixtures
- **NEVER make HTTP/HTTPS requests** to external services in test code
- **USE mock data and fixtures** for all external API testing
- **ISOLATE tests** from external dependencies

### Test Network Isolation
```python
# FORBIDDEN - Never make real external calls in tests
def test_api_integration():
    response = requests.get("https://api.external-service.com/data")
    assert response.status_code == 200

# CORRECT - Use mocks and fixtures
@patch('requests.get')
def test_api_integration(mock_get):
    mock_get.return_value.json.return_value = {"status": "success"}
    mock_get.return_value.status_code = 200
    
    result = api_client.get_data()
    assert result["status"] == "success"
```

### Approved Mock Fixtures
- **Use synthetic data** for all testing scenarios
- **Generate mock coordinates** that don't correspond to real locations
- **Use test API keys** that are clearly marked as test-only
- **Isolate test environment** from production data

## Data Protection

### Coordinate and Location Data
- **NEVER use real coordinates** that could identify actual households
- **ALWAYS use synthetic test data** for coordinates and locations
- **ROUND coordinates** to remove precision that could identify real locations
- **USE clearly marked test data** that cannot be confused with real data

### Test Data Generation
```python
import random
from typing import Tuple

def generate_test_coordinates() -> Tuple[float, float]:
    """Generate synthetic coordinates for testing that don't identify real locations"""
    # Use clearly synthetic ranges that don't correspond to real populated areas
    lat = random.uniform(0.0, 1.0)  # Synthetic range
    lon = random.uniform(0.0, 1.0)  # Synthetic range
    return lat, lon

def generate_test_hazard_data() -> List[Dict]:
    """Generate synthetic hazard data for testing"""
    return [
        {
            "id": f"test_hazard_{i}",
            "type": "fire",
            "coordinates": [generate_test_coordinates() for _ in range(4)],
            "severity": "high",
            "confidence": 0.85,
            "timestamp": "2024-01-01T00:00:00Z",
            "_test_data": True  # Clearly mark as test data
        }
        for i in range(5)
    ]
```

### Personal Information Protection
- **NEVER include real names, addresses, or phone numbers** in test data
- **NEVER use real emergency contact information** in tests
- **ALWAYS use clearly synthetic data** for all personal information
- **REDACT any accidentally included personal information**

## API Security

### Input Validation
- **VALIDATE all input data** to prevent injection attacks
- **SANITIZE user inputs** before processing
- **IMPLEMENT rate limiting** to prevent abuse
- **USE proper HTTP status codes** for different error conditions

### Secure API Implementation
```python
from fastapi import HTTPException, Depends
from pydantic import BaseModel, validator
import re

class SecureRequest(BaseModel):
    query: str
    location: Tuple[float, float]
    
    @validator('query')
    def validate_query(cls, v):
        # Sanitize input to prevent injection
        if not re.match(r'^[a-zA-Z0-9\s\-_]+$', v):
            raise ValueError('Invalid characters in query')
        if len(v) > 100:
            raise ValueError('Query too long')
        return v.strip()
    
    @validator('location')
    def validate_location(cls, v):
        lat, lon = v
        # Validate coordinate ranges
        if not (-90 <= lat <= 90) or not (-180 <= lon <= 180):
            raise ValueError('Invalid coordinate range')
        return v

@app.post("/api/search")
async def secure_search(request: SecureRequest):
    # Additional validation
    if not request.query or len(request.query.strip()) == 0:
        raise HTTPException(status_code=400, detail="Query cannot be empty")
    
    # Process request safely
    return await search_service.search(request.query, request.location)
```

### Rate Limiting
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.get("/api/data")
@limiter.limit("100/minute")
async def get_data(request: Request):
    # Rate limited endpoint
    return await data_service.get_data()
```

## Error Handling Security

### Secure Error Messages
- **NEVER expose internal system details** in error messages
- **NEVER include stack traces** in client-facing errors
- **NEVER reveal database schema** or internal structure
- **ALWAYS provide generic error messages** to clients

### Secure Error Handling
```python
import logging
from fastapi import HTTPException

# FORBIDDEN - Never expose internal details
try:
    result = database.query("SELECT * FROM users WHERE id = %s", user_id)
except Exception as e:
    raise HTTPException(status_code=500, detail=f"Database error: {e}")

# CORRECT - Generic error messages
try:
    result = database.query("SELECT * FROM users WHERE id = %s", user_id)
except Exception as e:
    logger.error(f"Database query failed for user {user_id}: {e}")
    raise HTTPException(status_code=500, detail="Internal server error")
```

### Logging Security
```python
import logging
import json

# Secure logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

def secure_log(level: str, message: str, **kwargs):
    """Log message with sensitive data redaction"""
    # Redact sensitive fields
    redacted_kwargs = {}
    for key, value in kwargs.items():
        if 'password' in key.lower() or 'key' in key.lower() or 'token' in key.lower():
            redacted_kwargs[key] = '[REDACTED]'
        else:
            redacted_kwargs[key] = value
    
    log_message = f"{message} - {json.dumps(redacted_kwargs)}"
    getattr(logging, level)(log_message)
```

## File System Security

### File Access Restrictions
- **NEVER read or write** to system directories outside the project
- **NEVER access** user home directories or system files
- **NEVER modify** configuration files outside the project
- **ALWAYS validate file paths** before accessing files

### Secure File Operations
```python
import os
from pathlib import Path

def secure_file_read(file_path: str) -> str:
    """Securely read file with path validation"""
    # Validate path is within project directory
    project_root = Path(__file__).parent.parent
    full_path = project_root / file_path
    
    # Ensure path is within project
    try:
        full_path.resolve().relative_to(project_root.resolve())
    except ValueError:
        raise ValueError("File path outside project directory")
    
    # Check file exists and is readable
    if not full_path.exists():
        raise FileNotFoundError("File not found")
    
    if not os.access(full_path, os.R_OK):
        raise PermissionError("File not readable")
    
    return full_path.read_text()
```

## Development Security

### Code Review Security
- **REVIEW all code changes** for security vulnerabilities
- **CHECK for hardcoded secrets** or sensitive data
- **VERIFY input validation** is properly implemented
- **ENSURE error handling** doesn't expose sensitive information

### Security Checklist
Before committing any code, verify:
- [ ] No hardcoded secrets or API keys
- [ ] No real coordinates or personal information in test data
- [ ] Input validation implemented for all user inputs
- [ ] Error messages don't expose internal details
- [ ] Logging doesn't include sensitive information
- [ ] File operations are restricted to project directory
- [ ] Network calls in tests use mocks, not real services

## Production Security

### Deployment Security
- **USE environment variables** for all configuration
- **IMPLEMENT proper CORS** configuration
- **USE HTTPS** for all production endpoints
- **IMPLEMENT security headers** (X-Content-Type-Options, X-Frame-Options, etc.)

### Security Headers
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com"],  # Configure for production
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)

@app.middleware("http")
async def security_headers(request: Request, call_next):
    response = await call_next(request)
    
    # Security headers
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    
    return response
```

## Security Monitoring

### Security Logging
- **LOG all security-relevant events** (failed logins, rate limit violations, etc.)
- **MONITOR for suspicious activity** patterns
- **ALERT on security violations** or potential breaches
- **REVIEW security logs** regularly

### Security Monitoring Implementation
```python
import logging
from datetime import datetime

security_logger = logging.getLogger('security')

def log_security_event(event_type: str, details: dict):
    """Log security-relevant events"""
    security_logger.warning(f"Security Event: {event_type} - {json.dumps(details)}")

def monitor_rate_limiting(request: Request):
    """Monitor rate limiting violations"""
    if hasattr(request.state, 'rate_limit_exceeded'):
        log_security_event('rate_limit_exceeded', {
            'ip': get_remote_address(request),
            'endpoint': request.url.path,
            'timestamp': datetime.utcnow().isoformat()
        })
```

This security standard ensures that the disaster response system maintains the highest security standards while protecting sensitive information and preventing security vulnerabilities.